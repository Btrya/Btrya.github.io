## 概述

本章主要是总结常见的排序算法，将会介绍他们的排序原理，对应的最好时间复杂度、最差时间复杂度、平均时间复杂度以及空间复杂度等，最重要是排序的源码，将利用一些简单的例题来帮助大家更好的理解排序算法。

阅读本章代码时建议自己mock一个无序数组，然后多加log去看看每次数组的变化，能更好的吸收以下内容。

## 时间复杂度O(n^2)级排序算法

### 冒泡排序

冒泡排序可能是大家入门的时候常看到的排序算法。

通常来说，冒泡排序有三种写法：
- 一边比较一边向后`两两交换`，将最大值/最小值冒泡到最后一位;
- 对上一种做法的优化：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不需要再继续排序;
- 再对上一种做法进行优化：再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较

#### 第一种写法：
```js
function bubbleSort(arr) {
  const n = arr.length
  // n - 1: 只需要遍历前 n - 1个
  for (let i = 0; i < n - 1; ++i) {
    // n - 1 - i: 由 i 下标出发遍历到 n - 1 下标处
    for (let j = 0; j < n - 1 - i; ++j) {
      // 如果左边的数比右边大，就交换，保证右边的数字最大。 换言之就是将数组从小到大排序
      if (arr[j] > arr[j + 1]) { // 更大的得在后面
        // 平平无奇交换函数
        swap(arr, j, j + 1)
      }
    }
  }
}
// 交换元素
function swap(arr, i, j) {
  let temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
  // 当然你也可以使用es6语法 [arr[i], arr[j]] = [arr[j], arr[i]]
}
```

以上的做法是`将数字两两比较`，且规定了 `“谁大站右边”(由你实际业务决定)`，经过 n - 1 轮的比较后排序完成，整个过程就像一个个气泡不断上浮，所以被叫做“冒泡排序”

#### 由第一种写法改良而来的第二种写法：
```js
function bubbleSort(arr) {
  // 初始化变量 swapped 为 true，该变量用于 记录当前轮次的比较是否发生过交换 ，初始化为 true 先让程序往下跑
  let swapped = true
  const n = arr.length
  // n - 1: 只需要遍历前 n - 1个
  for (let i = 0; i < n - 1; ++i) {
    // 如果没有发生过交换，说明剩余部分已经是有序的了，可以提前结束遍历  (通常我们称之为 剪枝 ，即再往下跑也没有意义了，已经完成任务了，可以提前结束程序)
    if (!swapped) break
    // 正常进入循环，先设置为 false ，如果发生了交换再设置为 true
    swapped = false 
    // n - 1 - i: 由 i 下标出发遍历到 n - 1 下标处
    for (let j = 0; j < n - 1 - i; ++j) {
      // 如果左边的数大于右边的数，则交换，保证右边的数字最大
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
        // 发生了交换 我们把 swapped 设置为 true
        swapped = true
      }
    }
  }
}
// 交换元素
function swap(arr, i, j) {
  let temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
  // 当然你也可以使用es6语法 [arr[i], arr[j]] = [arr[j], arr[i]]
}
```

这种写法基本原理还是 当最外层 `for` 循环经过一轮，剩余数字中的最大值就会被移动到当前轮次的最后一位
相对于第一种写法的优点在于：`如果一轮比较中没有发生过交换，则停止排序，减少无用的遍历`

看一个gif来更好的理解吧：

![冒泡排序第二种演示](https://btrya.github.io/assets/images/sort-assets/冒泡排序第二种.gif)

我们可以看到：
- 第一轮遍历的时候把数字 6 移动到最右
- 第二轮遍历把数字 5 移动到最右，同时中途把数字 1 和 2 也排了序
- 第三轮遍历的时候没有发生交换，此时排序已经完成了，结束遍历


#### 在第二种写法的基础上优化出第三种写法：
```js
function bubbleSort(arr) {
  // 写法二变量定义：
  let swapped = true
  const n = arr.length
  // 最后一个没有经过排序的元素的下标
  let indexOfLastUnsortedElement = n - 1
  // 上次交换的位置
  let swappedIndex = -1
  while (swapped) {
    // 正常进入循环，先设置为 false ，如果发生了交换再设置为 true
    swapped = false
    for (let i = 0; i < indexOfLastUnsortedElement; ++i) {
      // 如果左边的数比右边的数大，就叫唤，保证右边的数最大
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1)
        // 发生了交换， swapped设置为 true， swappedIndex更新到对应下标
        swapped = true
        swappedIndex = i
      }
    }
    // 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置
    indexOfLastUnsortedElement = swappedIndex
  }
}
// 交换元素
function swap(arr, i, j) {
  let temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
  // 当然你也可以使用es6语法 [arr[i], arr[j]] = [arr[j], arr[i]]
}
```

第三种写法看起来稍微复杂点，最外层的 `while` 循环每一轮，剩余数字中的最大值就会被移动到当前轮次的最后一位

`在下一轮比较的时候，只需要比较到上一轮最后一次发生交换的位置即可，因为后面的所有元素都没有发生过交换，已经是有序的了`

当一轮比较从头到尾都没有发生过交换，则表示整个列表已经有序，排序完成

#### 冒泡排序 时间复杂度 & 空间复杂度

冒泡排序经过多次的优化，它的空间复杂度为 O(1), 时间复杂度为O(n^2)
第二、三种写法由于经过优化，最好时间复杂度可以达到O(n)

最好情况: `[1, 2, 3, 4, 5, 6, 7]` 数组本身就是有序的，只需要遍历一次，由于没有发生过交换，遍历结束

最差情况: `[7, 6, 5, 4, 3, 2, 1]` 数组本身是逆序的，每次比较都有交换

所以我们可以看到优化后的冒泡排序平均时间复杂度仍然是 O(n^2)，这些优化对算法的性能没有`质的提升`(防抬杠， 抬杠就你对)

#### 总结

冒泡排序并不值得推荐，但却是必须知道的
因为冒泡排序是所有排序算法的祖宗，犹如`hello world`

#### 例题
1. [leetcode 283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)
2. [剑指offer 45.把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

## *附送数组元素交换技巧

我们看到冒泡排序是一定需要使用到 `交换数组中两个元素的位置` 的，那么这里有一个常见的面试题：

### 怎样在不引入第三个中间变量的情况下，完成两个数组的交换

首先我们先不要提 `[arr[i], arr[j]] = [arr[j], arr[i]]`

我们可以使用一个数学上的技巧

```js
arr[j + 1] = arr[j + 1] + arr[j]
arr[j] = arr[j + 1] - arr[j]
arr[j + 1] = arr[j + 1] - arr[j]
```

这种写法难记且存在数字越界的风险

最佳的方案是通过位运算符来完成数字交换: (^ 是异或运算符)

```js
arr[i] = arr[i] ^ arr[j]  // a = a ^ b
arr[j] = arr[j] ^ arr[i]  // b = a ^ b
arr[i] = arr[i] ^ arr[j]  // a = a ^ b
```

这里对位运算符的使用技巧先不做深究，感兴趣可以留言 我考虑出一期位运算符相关算法题特辑。