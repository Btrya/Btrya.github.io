## 概述

本章主要是总结常见的排序算法，将会介绍他们的排序原理，对应的最好时间复杂度、最差时间复杂度、平均时间复杂度以及空间复杂度等，最重要是排序的源码，将利用一些简单的例题来帮助大家更好的理解排序算法。

阅读本章代码时建议自己mock一个无序数组，然后多加log去看看每次数组的变化，能更好的吸收以下内容。

## 时间复杂度O(n^2)级排序算法

### 冒泡排序

冒泡排序可能是大家入门的时候常看到的排序算法。

通常来说，冒泡排序有三种写法：
- 一边比较一边向后`两两交换`，将最大值/最小值冒泡到最后一位;
- 对上一种做法的优化：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不需要再继续排序;
- 再对上一种做法进行优化：再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较

#### 第一种写法：
```js
function bubbleSort(arr) {
  const n = arr.length
  // n - 1: 只需要遍历前 n - 1个
  for (let i = 0; i < n - 1; ++i) {
    // n - 1 - i: 由 i 下标出发遍历到 n - 1 下标处
    for (let j = 0; j < n - 1 - i; ++j) {
      // 如果左边的数比右边大，就交换，保证右边的数字最大。 换言之就是将数组从小到大排序
      if (arr[j] > arr[j + 1]) { // 更大的得在后面
        // 平平无奇交换函数
        swap(arr, j, j + 1)
      }
    }
  }
}
// 交换元素
function swap(arr, i, j) {
  let temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
  // 当然你也可以使用es6语法 [arr[i], arr[j]] = [arr[j], arr[i]]
}
```

以上的做法是`将数字两两比较`，且规定了 `“谁大站右边”(由你实际业务决定)`，经过 n - 1 轮的比较后排序完成，整个过程就像一个个气泡不断上浮，所以被叫做“冒泡排序”

#### 由第一种写法改良而来的第二种写法：
```js
function bubbleSort(arr) {
  // 初始化变量 swapped 为 true，该变量用于 记录当前轮次的比较是否发生过交换 ，初始化为 true 先让程序往下跑
  let swapped = true
  const n = arr.length
  // n - 1: 只需要遍历前 n - 1个
  for (let i = 0; i < n - 1; ++i) {
    // 如果没有发生过交换，说明剩余部分已经是有序的了，可以提前结束遍历  (通常我们称之为 剪枝 ，即再往下跑也没有意义了，已经完成任务了，可以提前结束程序)
    if (!swapped) break
    // 正常进入循环，先设置为 false ，如果发生了交换再设置为 true
    swapped = false 
    // n - 1 - i: 由 i 下标出发遍历到 n - 1 下标处
    for (let j = 0; j < n - 1 - i; ++j) {
      // 如果左边的数大于右边的数，则交换，保证右边的数字最大
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
        // 发生了交换 我们把 swapped 设置为 true
        swapped = true
      }
    }
  }
}
// 交换元素
function swap(arr, i, j) {
  let temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
  // 当然你也可以使用es6语法 [arr[i], arr[j]] = [arr[j], arr[i]]
}
```

这种写法基本原理还是 当最外层 `for` 循环经过一轮，剩余数字中的最大值就会被移动到当前轮次的最后一位

相对于第一种写法的优点在于：`如果一轮比较中没有发生过交换，则停止排序，减少无用的遍历`

看一个gif来更好的理解吧：

![冒泡排序第二种演示](https://btrya.github.io/assets/images/sort-assets/冒泡排序第二种.gif)

我们可以看到：
- 第一轮遍历的时候把数字 6 移动到最右
- 第二轮遍历把数字 5 移动到最右，同时中途把数字 1 和 2 也排了序
- 第三轮遍历的时候没有发生交换，此时排序已经完成了，结束遍历


#### 在第二种写法的基础上优化出第三种写法：
```js
function bubbleSort(arr) {
  // 写法二变量定义：
  let swapped = true
  const n = arr.length
  // 最后一个没有经过排序的元素的下标
  let indexOfLastUnsortedElement = n - 1
  // 上次交换的位置
  let swappedIndex = -1
  while (swapped) {
    // 正常进入循环，先设置为 false ，如果发生了交换再设置为 true
    swapped = false
    for (let i = 0; i < indexOfLastUnsortedElement; ++i) {
      // 如果左边的数比右边的数大，就叫唤，保证右边的数最大
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1)
        // 发生了交换， swapped设置为 true， swappedIndex更新到对应下标
        swapped = true
        swappedIndex = i
      }
    }
    // 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置
    indexOfLastUnsortedElement = swappedIndex
  }
}
// 交换元素
function swap(arr, i, j) {
  let temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
  // 当然你也可以使用es6语法 [arr[i], arr[j]] = [arr[j], arr[i]]
}
```

第三种写法看起来稍微复杂点，最外层的 `while` 循环每一轮，剩余数字中的最大值就会被移动到当前轮次的最后一位

`在下一轮比较的时候，只需要比较到上一轮最后一次发生交换的位置即可，因为后面的所有元素都没有发生过交换，已经是有序的了`

当一轮比较从头到尾都没有发生过交换，则表示整个列表已经有序，排序完成

#### 冒泡排序 时间复杂度 & 空间复杂度

冒泡排序经过多次的优化，它的空间复杂度为 O(1), 时间复杂度为O(n^2)
第二、三种写法由于经过优化，最好时间复杂度可以达到O(n)

最好情况: `[1, 2, 3, 4, 5, 6, 7]` 数组本身就是有序的，只需要遍历一次，由于没有发生过交换，遍历结束

最差情况: `[7, 6, 5, 4, 3, 2, 1]` 数组本身是逆序的，每次比较都有交换

所以我们可以看到优化后的冒泡排序平均时间复杂度仍然是 O(n^2)，这些优化对算法的性能没有`质的提升`(防抬杠， 抬杠就你对)

#### 总结

冒泡排序并不值得推荐，但却是必须知道的
因为冒泡排序是所有排序算法的祖宗，犹如`hello world`

#### 例题
1. [leetcode 283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)
2. [剑指offer 45.把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

## *附送数组元素交换技巧

我们看到冒泡排序是一定需要使用到 `交换数组中两个元素的位置` 的，那么这里有一个常见的面试题：

### 怎样在不引入第三个中间变量的情况下，完成数组两个元素的交换

首先我们先不要提 `[arr[i], arr[j]] = [arr[j], arr[i]]`

我们可以使用一个数学上的技巧

```js
arr[j + 1] = arr[j + 1] + arr[j]
arr[j] = arr[j + 1] - arr[j]
arr[j + 1] = arr[j + 1] - arr[j]
```

这种写法难记且存在数字越界的风险

最佳的方案是通过位运算符来完成数字交换: (^ 是异或运算符)

```js
arr[i] = arr[i] ^ arr[j]  // a = a ^ b
arr[j] = arr[j] ^ arr[i]  // b = a ^ b
arr[i] = arr[i] ^ arr[j]  // a = a ^ b
```

这里对位运算符的使用技巧先不做深究，感兴趣可以留言 我考虑出一期位运算符相关算法题特辑。


### 选择排序

选择排序的思想就是: `双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位`

直接上代码：

```js
// 以从小到大排序演示
function selectionSort(arr) {
  let minIndex
  const n = arr.length
  for (let i = 0; i < n - 1; ++i) {
    minIndex = i
    for (let j = i + 1; j < n; ++j) {
      // 记录最小值的下标
      if (arr[minIndex] > arr[j]) {
        minIndex = j
      }
    }
    // 将最小元素交换至首位
    let temp = arr[i]
    arr[i] = arr[minIndex]
    arr[minIndex] = temp
  }
}
```

选择排序好比打擂台，所有数字挨个打擂，谁的拳头更硬/软就产生新的擂主，交换至首位，打 n - 1 轮，数字就排序完成了

为了方便理解，来看一下动图演示吧

![快速排序演示图](https://btrya.github.io/assets/images/sort-assets/选择排序.gif)

看图我们可以发现，每一轮排序都找到了当前那一轮的最小值，并被交换到当前轮的首位，这就是`选择排序`

#### 二元选择排序

选择排序依然是可以优化的，没想到吧啊哈哈哈

优化的思想： `每轮遍历找到最小值，干嘛不把最大值也找出来`

这种优化过后的快速排序 我们称之为 `二元选择排序` 

每轮遍历记录最小值和最大值，可以把数组需要遍历的范围缩小一倍。

上代码：

```js
function selectionSort2(arr) {
  let minIndex, maxIndex
  const n = arr.length
  // i 只要遍历一半啦
  for (let i = 0; i < n / 2; ++i) {
    minIndex = i
    maxIndex = i
    for (let j = i + 1; j < n - i; ++j) {
      // 发现更小的数，记录下标
      if (arr[minIndex] > arr[j]) {
        minIndex = j
      }
      // 发现更大的数，记录下标
      if (arr[maxIndex] < arr[j]) {
        maxIndex = j
      }
    }
    // minIndex 和 maxIndex 相同，那么他们一定都是 i，且后面的所有数字都与 arr[i] 相等，说明排序已经完成
    if (minIndex == maxIndex) break
    // 将最小元素交换至首位
    let temp = arr[i]
    arr[i] = arr[minIndex]
    arr[minIndex] = temp
    // 如果最大值的下标刚好是 i ，由于 arr[i] 和 arr[minIndex] 已经交换了，所以要更新 maxIndex 的值 这个是重点
    if (maxIndex == i) maxIndex = minIndex
    // 将最大元素交换至末尾
    let lastIndex = n - 1 - i
    temp = arr[lastIndex]
    arr[lastIndex] = arr[maxIndex]
    arr[maxIndex] = temp
  }
}
```

我们可以看到利用多一个变量 我们最外层的遍历只需要遍历一半就可以了

注意代码里很重要的一句 `if (maxIndex == i) maxIndex = minIndex` ，这行代码位于 `交换最小值` 和 `最欢最大值`的代码的中间

这是用来解决一种特殊情况的：如果最大值的下标等于 `i`, 也就是说 `arr[i]` 就是最大值，由于 `arr[i]` 是当前遍历轮次的首位，已经和 `arr[minIndex]` 交换了，所以最大值的下标需要跟踪到 `arr[i]` 最新的下标 `minIndex`

#### 二元选择排序的效率

虽然二元选择排序使得排序外层的遍历范围缩小了，但是for循环内做的事情是翻了一倍的。

也就是说二元选择排序无法将排序的效率提升一倍`(质的提升)`。

但实测的话二元选择排序比选择排序速度是要快一点点的，提升的原因在于：
- 选择排序外层循环 `i` 需要加到 `arr.length - 1`， 二元选择排序中 `i` 只需要加到 `arr.length / 2`
- 选择排序内层循环 `j` 需要加到 `arr.length`， 二元选择排序中 `j` 只需要加到 `arr.length - i`

#### 选择排序 时间复杂度 & 空间复杂度

选择排序使用两层循环，时间复杂度为 O(n^2)，使用有限个变量，空间复杂度为 O(1) 

二元选择排序比选择排序稍快，但治标不治本，其优化仍不足以改变其时间复杂度，故时间复杂度为 O(n^2)，使用有限个变量，空间复杂度为 O(1) 

#### 选择排序与冒泡排序的异同

相同点：
- 都是两层循环，时间复杂度都是O(n^2)
- 都只用了有限的变量，空间复杂度O(1)

不同点：
- 冒泡排序在比较的时候就不断两两交换; 而选择排序多了一个变量用来保存最小/最大值的下标，遍历完成后才交换，减少了交换的次数
- 冒泡排序是稳定的，选择排序是不稳定的

#### 怎么理解这个稳定和不稳定呢？

很简单，冒泡排序就是当左边数字比右边数字大/小，才会发生交换，相等数字是不会发生交换的，我们就认为他是稳定的。

而选择排序，最大/小值和首位交换的过程中就容易破坏稳定性，比如数组：`[2, 2, 1]` 在第一次交换的时候 原数组的两个 2 的相对顺序就被改变了，我们认为他是不稳定的。

#### 算法稳定性有什么用？实际业务哪里会用到？

举个例子，比如我们需要对商品做排序，商品`「价格」「销量」`两个属性，我们要求按照 `价格从高到低排序，再按销量从高到低排序`

这时，你要`保证销量相同的两个商品的顺序仍然保持价格从高到低的顺序`，你就必须考虑算法的稳定性。

#### 快速排序不稳定，怎么让他变稳定？

我们是否可以 `新开一个数组，将每轮找出的最小值依次推入新数组`，这样快速排序是不是就变稳定了？

#### 冒泡排序太稳定了，怎么让他不稳定？

设想一下，我们使用冒泡排序的时候，判断条件是 `「左边的数大于右边的数，就交换」`，一旦你修改成`「左边的数大于等于右边的数，就交换」`，那么冒泡排序就变得不稳定了

#### 例题

1. [leetcode 215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
2. [leetcode 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)
### 插入排序

插入排序的思想非常简单，想想你打斗地主的时候，一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序

插入排序有两种写法：
- 交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置
- 移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入`一次`即可

#### 交换法插入排序

```js
function insertSort(arr) {
  const n = arr.length
  // 从第二个数字开始，往前插入数字
  for (let i = 1; i < n; ++i) {
    // j 记录当前数字下标
    let j = i
    // j >= 1: j不能回到第一个数字下标 不然 j-1 减哪去了; arr[j] < arr[j - 1]: 当前数字比前一个数字小，则将当前数字与前一个数字交换
    while (j >= 1 && arr[j] < arr[j - 1]) {
      swap(arr, j, j - 1)
      // 更新当前数字下标
      j--
    }
    // 当然上面的 while 觉得不好记可以使用 for ，使用while是为了更好注释出来
    // for (let j = i; j >= 1 && arr[j] < arr[j - 1]; --j) {
    //   swap(arr, j, j - 1)
    // }
  }
}
// 老朋友了
function swap(arr, i, j) {
  arr[i] = arr[i] ^ arr[j]
  arr[j] = arr[i] ^ arr[j]
  arr[i] = arr[i] ^ arr[j]
}
```

当数字少于两个时，不存在排序问题，所以我们直接从第二个数字开始往前插入数字

整个过程就像是军训排队列，已经有这么一排人了，你站在第一个，发现你比第二个高，你就和他换，诶一直换到下一个人比你高，这不就找到你该呆的位置了吗

#### 移动法插入排序

在交换法插入排序中，每次交换数字时， `swap` 函数都会进行三次赋值操作。但是实际上呢，新插入的这个数字可能刚换到新的位置上不久在下一次比较的时候又要换位置。

因此有了移动法插入排序：让新插入的数字先进行比较，前面比它大的数字不断向后移动，直到找到适合这个新数字的位置后，新数字只做一次插入操作即可。

上代码！！！

```js
function insertSort(arr) {
  const n = arr.length
  // 从第二个数字开始，往前插入数字
  for (let i = 1; i < n; ++i) {
    let currentNum = arr[i]
    let j = i - 1
    // 1.遇到小于或等于 currentNum 的数字跳出循环 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNum 的数字，跳出循环 这时候 j 是 -1 ，所以 currentNum 会坐到 arr[-1 + 1] = arr[0] 的位置，也就是数组头部位置
    while (j >= 0 && currentNum < arr[j]) {
      // 寻找插入位置的过程中，不断地将比 currentNum 大的数字向后挪  
      arr[j + 1] = arr[j]
      j--
    }
    // currentNum 坐到对应位置
    arr[j + 1] = currentNum
  }
}
```

来一个直观的gif感受一下8

![插入排序演示图](https://btrya.github.io/assets/images/sort-assets/插入排序.gif)

有的好朋友可能已经发现了插入排序的过程不会破坏原数组中相同关键字的相对次序，没错！！所以插入排序是一种`稳定`排序算法

#### 插入排序 时间复杂度 & 空间复杂度

插入排序过程需要两层循环，时间复杂度为 O(n^2); 只需要常量级的临时变量，空间复杂度为 O(1)。

#### 例题 

1. [leetcode 147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/) 该题需要链表基础，但是原理和数组插入排序相似，试试看吧
2. [leetcode 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

## 时间复杂度O(nlogn)级排序算法

### 希尔排序

### 堆排序

### 快速排序

### 归并排序


## 时间复杂度O(n)级排序算法

### 计数排序

### 基数排序

### 桶排序

## JS源码 Array.sort() 原理解析