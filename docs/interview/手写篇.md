## 手写Object.create

作用：将传入的对象作为原型

引申问题：为什么Object.create()要创建一个function F() {}不直接return {__proto__: obj}？
{__proto__:obj}不能保证此对象的原型就是obj，但是F.prototype = obj;return new F();浏览器就会根据自己的实现去将返回实例的原型设置为obj。（__proto__存在于非IE）

```js
function create(obj) {
  function F() {}
  F.prototype = obj
  return new F()
}
```

## 手写instanceof

作用：`instanceof` 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置

实现步骤：
1. 获取类型的原型
2. 获取对象的原型
3. 循环判断类型的原型是否等于对象的原型，直到对象原型为`null`，表示走到了原型链的尽头

```js
function myInstanceof(left, right) {
  let prototype = right.prototype, // 获取类型的原型
      proto = Object.getPrototypeOf(left) // 获取对象的原型
  while (true) {
    if (!proto) return false // 走到尽头 对象原型为null
    if (proto == prototype) return true
    proto = Object.getPrototypeOf(proto) // 获取下一个对象原型
  }
}
```

## 手写new操作符
在调用`new`的过程中挥发上以下4件事情：
1. 首先创建了一个新的空对象
2. 设置原型，将对象的原型设置为函数的`prototype`对象
3. 让函数的`this`指向这个对象，执行构造函数的代码(为这个新对象添加属性)
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象

```js
function objectFactory() {
  let newObject = null
  let constructor = Array.prototype.shift.call(arguments)
  let result = null
  // 判断参数是否是一个函数
  if (typeof constructor !== 'function') {
    console.error('type error')
    return
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype)
  // this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments)
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function")
  // 判断返回结果
  return flag ? result : newObject
}
// 使用方法
objectFactory(构造函数, 初始化参数)
```